#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vi:ts=2:sw=2:syn=python
#
# vtech-simics-keygen - keygen.py
# a reverse-engineering exercise on
# counterfeit license generation software
#
# DISCLAIMER: this work has been done on the analysis of
# distributed cracking software, namely keygen.exe for the
# solely purpose of education on malicious software techniques
#
# keygen-releaser: Saint & Sinners Group (SSG)
# keygen-language: Borland Delphi 5.0 KOL/MCK
# vendor-licensor: Macrovision FLEXlm 9.2.1
# vendor-software: Virtutech SIMICS 3.0.29
#
# ref.:
#  - FLEXlm - Programmers Manual by Macrovision
#  - FLEXlm - Reference Guide by Macrovision
#  - lm_new.c as generated by lmnewgen.exe
#
# cid.: d554f6f77903a6e484a932c45e9f98da
#
# --

import io
import sys
import time
import struct
import getpass
import optparse
import datetime

VIRTUTECH_SIMICS_FEATURE_SET = [
  { 'name': 'eclipse',               'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'p_developer',           'version': '3.0', 'vendor': 'vtech', 'string': 'Tc;Am;Lc;U' },
  { 'name': 'devel_host_rh6-x86-64', 'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_host_win32-x86',  'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_host_rh6-x86',    'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_host_sol7-v9',    'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_distribution',    'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_large_system',    'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_real_network',    'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'devel_hindsight',       'version': '3.0', 'vendor': 'vtech', 'string': None         },
  { 'name': 'p_modelbuilder',        'version': '3.0', 'vendor': 'vtech', 'string': 'Tc;Gc;U'    },
  { 'name': 'host_rh6-x86-64',       'version': '3.0', 'vendor': 'vtech', 'string': 'model'      },
  { 'name': 'host_win32-x86',        'version': '3.0', 'vendor': 'vtech', 'string': 'model'      },
  { 'name': 'host_rh6-x86',          'version': '3.0', 'vendor': 'vtech', 'string': 'model'      },
  { 'name': 'host_sol7-v9',          'version': '3.0', 'vendor': 'vtech', 'string': 'model'      },
  { 'name': 'builder',               'version': '3.0', 'vendor': 'vtech', 'string': 'model'      },
]

VIRTUTECH_VENDORCODE_DUMP = (
  "\x04\x00\x00\x00" # VENDORCODE_{4..7} struct ver
  "\x60\x07\x33\x2A" # data[0] = 0x2A330760 (XOR'd)
  "\x6B\xF8\xDE\x18" # data[1] = 0x18DEF86B (XOR'd)
  "\x00\x3B\x9F\xE3" # keys[0] = 0xE39F3B00
  "\xC1\xAC\x63\x00" # keys[1] = 0x0063ACC1
  "\xAE\x67\x8A\x97" # keys[2] = 0x978A67AE
  "\x8E\xF8\x68\x0C" # keys[3] = 0x0C68F88E
  "\x09\x00"         # FLEXLM_VER_MAJOR(9)
  "\x00\x00"         # FLEXLM_VER_MINOR(0)
  "\x20\x00"         # FLEXLM_PATCH_CHR
  "09.0\x00"         # LM_BEHAVIOR_V9
)

class FLEXKeygen(object):
  """ keeping a somewhat similar behaviour to dissasembled delphi """
  VENDORMAGIC_V7   = 0x08BC0EF8 # used by l_xorname() on vendorcode keys
  SECLEN_SHORT     = 0x66D8B337 # whether to use 12-chars in keygen or more
  ANY_CODE         = 0xAB370FD2 # HOSTID_ANY code used in license generation
  NO_START_DATE    = 0x73D0C587 # license generation code when start date is unset
  PERMANENT_DATE   = "1-jan-0"  # license generation code for keys without expiration
  LRAND_R1         = 32363      # L'Ecuyer [1988] recommended MLCG value for M1 @rand()
  LRAND_R2         = 31727      # L'Ecuyer [1988] recommended MLCG value for M2 @rand()
  LRAND_R3         = 31657      # L'Ecuyer [1988] recommended MLCG value for M3 @rand()
  MAX_VENDOR_NAME  = 10         # vendor maximum length, needed by l_xorname()
  SIG_SIZE         = 4          # vendor-based signature needed by key5()

  def __init__(self):
    self.key5_order = [0] * 4
    self.key5_uniqx = 0xF0CE1B3B

  @staticmethod
  def l_xorname(vendor, vc):
      vendor += '\0' * FLEXKeygen.MAX_VENDOR_NAME
      vc.keys[0] ^= ( # EQU 0x8846418E
          (ord(vendor[0]) <<  0) ^ (ord(vendor[1]) <<  8) ^
          (ord(vendor[2]) << 16) ^ (ord(vendor[3]) << 24) ^ FLEXKeygen.VENDORMAGIC_V7)
      vc.keys[1] ^= ( # EQU 0x60DFA25C
          (ord(vendor[2]) <<  0) ^ (ord(vendor[5]) <<  8) ^
          (ord(vendor[7]) << 16) ^ (ord(vendor[4]) << 24) ^ FLEXKeygen.VENDORMAGIC_V7)
      vc.keys[2] ^= ( # EQU 0x9F42693E
          (ord(vendor[4]) <<  0) ^ (ord(vendor[6]) <<  8) ^
          (ord(vendor[1]) << 16) ^ (ord(vendor[6]) << 24) ^ FLEXKeygen.VENDORMAGIC_V7)
      vc.keys[3] ^= ( # EQU 0x67B18076
          (ord(vendor[5]) <<  0) ^ (ord(vendor[0]) <<  8) ^
          (ord(vendor[2]) << 16) ^ (ord(vendor[3]) << 24) ^ FLEXKeygen.VENDORMAGIC_V7)

  def key5(self, vendor, vc):
      self.key5_order[3] ^= int(time.time()) ^ 0x12001C
      self.key5_order[0] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0xC4) <<  0))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0xDB0095
      self.key5_order[2] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x99) << 16))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x1000EC
      self.key5_order[0] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x36) << 24))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x9600F4
      self.key5_order[1] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0xAA) <<  0))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x6A0094
      self.key5_order[1] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0xD1) << 16))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x8700D5
      self.key5_order[1] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x0D) <<  8))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x8700D5
      self.key5_order[1] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x0D) <<  8))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x9600F4
      self.key5_order[1] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0xAA) <<  0))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0x8700D5
      self.key5_order[1] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x0D) <<  8))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0xB900DD
      self.key5_order[0] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0xF8) <<  8))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0xCC007B
      self.key5_order[0] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x40) << 16))[0]
      self.key5_order[3] ^= int(time.time()) ^ 0xCC007B
      self.key5_order[0] |= struct.unpack('<I', struct.pack('<I', (int(time.time()) & 0xFF ^ 0x40) << 16))[0]

      vendor_len = len(vendor)
      sig = [0] * FLEXKeygen.SIG_SIZE
      for i in range(0, FLEXKeygen.MAX_VENDOR_NAME): # EQU 0x06116A7D
        if sig[i % FLEXKeygen.SIG_SIZE] != ord(vendor[i % vendor_len]):
           sig[i % FLEXKeygen.SIG_SIZE] ^= ord(vendor[i % vendor_len])

      key5_xor_result = (((((( # EQU 0x829F0D2A
        (((sig[0] << 2 | sig[1]) | (sig[2] << 3)) | (sig[3] * 2)) ^
        (((self.key5_order[1] & 0xFF00) >>  8) <<  0)) ^
        (((self.key5_order[0] & 0x00FF) <<  8) <<  0)) ^ self.key5_uniqx) ^
        (((self.key5_order[0] & 0xFF00) >>  8) << 16)) ^
        (((self.key5_order[1] & 0x00FF) << 24) <<  0)) ^
        vc.keys[1] ^
        vc.keys[0])

      vc.data[0] ^= key5_xor_result
      vc.data[1] ^= key5_xor_result

      self.key5_order[3] -= 7

  @staticmethod
  def l_bin_date(start_date=None):
    d, m, y = [0] * 3
    if not start_date:
      today = datetime.datetime.today()
      d, m, y = today.day, today.month, today.year
    if y >= 1900: y -= 1900
    i = (y << 9) + d + 32 * m
    return "{:X}".format(i)

  @staticmethod
  def get_ver(version):
      return [int(s) for s in version.split('.', 1)]

  @staticmethod
  def reverse_bits(n):
      n = ((n & 0x55555555) <<  1) | ((n & 0xAAAAAAAA) >>  1)
      n = ((n & 0x33333333) <<  2) | ((n & 0xCCCCCCCC) >>  2)
      n = ((n & 0x0F0F0F0F) <<  4) | ((n & 0xF0F0F0F0) >>  4)
      return n

  @staticmethod
  def srand16(i1, i2, i3, seeds):
    seeds[0] = i1 % FLEXKeygen.LRAND_R1
    seeds[1] = i2 % FLEXKeygen.LRAND_R2
    seeds[2] = i3 % FLEXKeygen.LRAND_R3
    if not seeds[0] > 0: seeds[0] += FLEXKeygen.LRAND_R1 - 1
    if not seeds[1] > 0: seeds[1] += FLEXKeygen.LRAND_R2 - 1
    if not seeds[2] > 0: seeds[2] += FLEXKeygen.LRAND_R3 - 1
    return seeds

  @staticmethod
  def l_rand_modmult(a, b, c, m, s):
    s = b * (s - a * (s/a)) - c * (s/a)
    if s < 0: s += m
    return s

  @staticmethod
  def rand16(seeds, do_shift=False):
      seeds[0] = FLEXKeygen.l_rand_modmult(206, 157,  21, FLEXKeygen.LRAND_R1, seeds[0])
      seeds[1] = FLEXKeygen.l_rand_modmult(217, 146,  45, FLEXKeygen.LRAND_R2, seeds[1])
      seeds[2] = FLEXKeygen.l_rand_modmult(222, 142, 133, FLEXKeygen.LRAND_R3, seeds[2])
      z = seeds[0] - seeds[1]
      if z > 706:
        z -= FLEXKeygen.LRAND_R1 - 1
      z += seeds[2]
      if z < 1:
        z += FLEXKeygen.LRAND_R1 - 1
      if do_shift: return z >> 1
      return z

  @staticmethod
  def sign_encrypt(y):
    seeds = [0] * 3
    FLEXKeygen.srand16((y[1] << 8) + y[0], (y[3] << 8) + y[2], (y[5] << 8) + y[4], seeds)
    i1 = FLEXKeygen.rand16(seeds)
    i2 = FLEXKeygen.rand16(seeds)
    FLEXKeygen.srand16(i1, i2, (y[7] << 8) + y[6], seeds)
    i3 = FLEXKeygen.rand16(seeds)
    i1 = FLEXKeygen.rand16(seeds)
    i2 = FLEXKeygen.rand16(seeds)
    FLEXKeygen.srand16(i3, i1, i2, seeds)
    i4 = FLEXKeygen.rand16(seeds)
    i3 += i4 << 16
    i1 = FLEXKeygen.rand16(seeds)
    i2 = FLEXKeygen.rand16(seeds)
    FLEXKeygen.srand16(i4, i1, i2, seeds)
    i5 = FLEXKeygen.rand16(seeds)
    i6 = FLEXKeygen.rand16(seeds)
    i5 += i6 << 16
    for n in range(0, 4):
        y[0 + n] = FLEXKeygen.reverse_bits(i3 >> 8 * n) & 0xFF
    for n in range(0, 4):
        y[4 + n] = FLEXKeygen.reverse_bits(i5 >> 8 * n) & 0xFF
    return y

  @staticmethod
  def atox(y, seclen):
      hex_string = ''.join("{:02X}".format(b) for b in y)
      hex_string += '0' * (16 - len(hex_string))
      if seclen == FLEXKeygen.SECLEN_SHORT:
          return hex_string[0:12]
      return hex_string

  def l_string_key(self, p, p_len, vc, conf, seclen):
    vendor_mod_20 = ord(conf.vendor[0]) % 20
    p_len_div_8 = int(p_len / 8) # truncate
    p += '\0' * 8 # padding used to XOR y[]

    m = [ 3,  5,  4, 11,  9,  8,  3,  1,  8,  1,  2,  5,  2, 11, 10,  5,  3,  0,  1,  7,
          1, 10,  3,  7,  7,  3,  5, 11,  0,  1,  9,  4,  0,  4,  1, 10, 11,  8,  1,  3,
          8,  4,  2,  5,  6,  1,  0,  9,  4,  3,  8,  9,  0,  4,  2, 10,  3, 10,  8,  7,
          1, 11,  0,  3,  6,  5,  1,  0,  0,  2,  4,  8,  5,  0,  1,  4, 10,  3,  5,  1]

    key5_order_bytes = struct.pack('<%ldI' % len(self.key5_order), *self.key5_order)

    y = [0] * 8
    if p_len % 8:
        p_len_div_8 += 1

    p_dword_hop = 0
    for i in range(0, p_len_div_8):
      for n in range(0, 8):
        y[n] ^= ord(p[(p_dword_hop + n)])

      if i == 0:
        for n in range(0, 8):
          byte_shift = 8 * (n % 4)
          byte_shift_mask = 0xFF << 8 * (n % 4)
          seed_byte  = (vc.data[n >> 2] & byte_shift_mask) >> byte_shift
          seed_byte ^= ord(key5_order_bytes[m[vendor_mod_20 * 4 + (n % 4)]])
          y[n] ^= seed_byte # see lm_new.c for reference
          y[n] = FLEXKeygen.reverse_bits(y[n])

      FLEXKeygen.sign_encrypt(y)
      p_dword_hop += 8

    if seclen == FLEXKeygen.SECLEN_SHORT:
        y[7] = FLEXKeygen.reverse_bits(y[7]) & 0xFF
        y[6] = FLEXKeygen.reverse_bits(y[6]) & 0xFF
        y[0] = y[7] + y[0]                   & 0xFF
        y[1] = y[6] + y[1]                   & 0xFF
        y[6] = y[7] = 0x00

    return FLEXKeygen.atox(y, seclen)

  def real_crypt(self, conf, sdate, vc):
    ver_major, ver_minor = FLEXKeygen.get_ver(conf.version)
    d, m, y = conf.date_until.split('-', 2) # ('1', 'jan', '0')

    p  = str()                                        # unique stream used to generate SIGN=...
    p += struct.pack('<IB', FLEXKeygen.ANY_CODE, 0x0) # HOSTID_ANY code used to allow any mechanism
    p += conf.name.upper()                            # upper-case feature name (e.g.: 'p_developer')
    p += struct.pack('<BB', ver_major, ver_minor)     # split'd feature version (i.e.: '3.0' -> (3, 0))
    if conf.string: p += conf.string.upper()          # VENDOR_STRING content data plain text (optional)
    p += struct.pack('<BB', int(d), 0x0)              # PERMANENT_DATE: '1-jan-0' -> '1' -> 1, plus '\0'
    p += m.lower()                                    # PERMANENT_DATE: '1-jan-0' -> 'jan' -> 'jan'
    p += struct.pack('<I', FLEXKeygen.NO_START_DATE)  # code used when license start date is unset
    p += '\0'                                         # actually p is 2600~, see l_string_key()

    return self.l_string_key(p, len(p), vc, conf, FLEXKeygen.SECLEN_SHORT)

  def do(self, conf, vc):
    bin_date = '\0' * 4
    sdate = "start:today"
    if sdate.endswith("today"):
      bin_date = self.l_bin_date()

    conf.sign = self.real_crypt(conf, bin_date, vc)

class VendorCode(object):
  def __init__(self, dump):
    s = io.BytesIO(dump) # reads vc-data as an iostream
    self.type = list(struct.unpack(   '<I', s.read(4 * 1)))[0]
    self.data = list(struct.unpack(  '<II', s.read(4 * 2)))
    self.keys = list(struct.unpack('<IIII', s.read(4 * 4)))
    s.close()

class FeatureConfig(object):
  def __init__(self, feature_data):
    self.name       = feature_data['name']
    self.vendor     = feature_data['vendor']
    self.string     = feature_data['string']
    self.version    = feature_data['version']
    self.date_until = FLEXKeygen.PERMANENT_DATE
    self.sign = bytearray() # EQU "SIGN=AAABBBCCC..."

  def save(self, out_file):
    out_file.write("FEATURE %(name)s %(vendor)s %(version)s permanent uncounted " %
                  {'name': self.name, 'vendor': self.vendor, 'version': self.version })
    if self.string: out_file.write("VENDOR_STRING=\"%s\" " % (self.string))
    out_file.write("HOSTID=ANY SIGN=%(sign)s" % { 'sign': self.sign })
    out_file.write("\r\n") # better to use DOS/Windows CRLF ending

if __name__ == "__main__":
  parser = optparse.OptionParser(usage="%prog [--file FILE] [--user USER]", epilog="--")
  parser.add_option('-u', '--user', metavar="USER", dest="username", help="username that will run SIMICS")
  parser.add_option('-w', '--file', metavar="FILE", help="destination file (license.lic)", default="license.lic")

  opts, args = parser.parse_args()
  if not opts.username:
    host_username = getpass.getuser()
    try:
      opts.username = raw_input("User that will run SIMICS [%s]: " % host_username)
      if not opts.username.strip():
        opts.username = host_username
    except KeyboardInterrupt:
      sys.stdout.write("\n")
      sys.exit(0)

  try:
    with open(opts.file, 'w') as out_file:
      for FEATURE in VIRTUTECH_SIMICS_FEATURE_SET:
        vc = VendorCode(VIRTUTECH_VENDORCODE_DUMP)
        conf = FeatureConfig(feature_data=FEATURE)
        keygen = FLEXKeygen() # stores key5_order
        keygen.l_xorname(conf.vendor, vc)
        keygen.key5(conf.vendor, vc)

        if type(conf.string) == str:
          if conf.string.endswith(";U"):
            conf.string += opts.username

        keygen.do(conf, vc)
        conf.save(out_file)
  except IOError:
    sys.stderr.write("error: couldn't write ")
    sys.stderr.write("'%s'" % opts.file)
    sys.stderr.write("\n")
    sys.exit(2)

  sys.stdout.write("license written to ")
  sys.stdout.write("'%s'" % opts.file)
  sys.stdout.write("\n")

